{
  "language": "Solidity",
  "sources": {
    "contracts/DCAFactory/DCAFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.4;\n\nimport './DCAFactoryPairsHandler.sol';\n\ncontract DCAFactory is DCAFactoryPairsHandler, IDCAFactory {\n  constructor(IDCAGlobalParameters _globalParameters) DCAFactoryPairsHandler(_globalParameters) {}\n}\n"
    },
    "contracts/DCAFactory/DCAFactoryPairsHandler.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.4;\n\nimport '../DCAPair/DCAPair.sol';\nimport '../interfaces/IERC20Detailed.sol';\nimport '../interfaces/IDCAFactory.sol';\nimport '../interfaces/IDCAGlobalParameters.sol';\nimport '../libraries/CommonErrors.sol';\n\nabstract contract DCAFactoryPairsHandler is IDCAFactoryPairsHandler {\n  mapping(address => mapping(address => address)) internal _pairByTokens; // token0 => token1 => pair\n  address[] public override allPairs;\n  IDCAGlobalParameters public override globalParameters;\n\n  constructor(IDCAGlobalParameters _globalParameters) {\n    if (address(_globalParameters) == address(0)) revert CommonErrors.ZeroAddress();\n    globalParameters = _globalParameters;\n  }\n\n  function _sortTokens(address _tokenA, address _tokenB) internal pure returns (address _token0, address _token1) {\n    (_token0, _token1) = _tokenA < _tokenB ? (_tokenA, _tokenB) : (_tokenB, _tokenA);\n  }\n\n  function pairByTokens(address _tokenA, address _tokenB) external view override returns (address _pair) {\n    (address _token0, address _token1) = _sortTokens(_tokenA, _tokenB);\n    _pair = _pairByTokens[_token0][_token1];\n  }\n\n  function createPair(address _tokenA, address _tokenB) public override returns (address _pair) {\n    if (_tokenA == address(0) || _tokenB == address(0)) revert CommonErrors.ZeroAddress();\n    if (_tokenA == _tokenB) revert IdenticalTokens();\n    (address _token0, address _token1) = _sortTokens(_tokenA, _tokenB);\n    if (_pairByTokens[_token0][_token1] != address(0)) revert PairAlreadyExists();\n    _pair = address(new DCAPair(globalParameters, ISlidingOracle(address(0xe)), IERC20Detailed(_token0), IERC20Detailed(_token1)));\n    _pairByTokens[_token0][_token1] = _pair;\n    allPairs.push(_pair);\n    emit PairCreated(_token0, _token1, _pair);\n  }\n}\n"
    },
    "contracts/DCAPair/DCAPair.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.4;\npragma abicoder v2;\n\nimport './DCAPairParameters.sol';\nimport './DCAPairPositionHandler.sol';\nimport './DCAPairSwapHandler.sol';\nimport './DCAPairLoanHandler.sol';\n\ncontract DCAPair is DCAPairParameters, DCAPairSwapHandler, DCAPairPositionHandler, DCAPairLoanHandler, IDCAPair {\n  constructor(\n    IDCAGlobalParameters _globalParameters,\n    ISlidingOracle _oracle,\n    IERC20Detailed _tokenA,\n    IERC20Detailed _tokenB\n  ) DCAPairParameters(_globalParameters, _tokenA, _tokenB) DCAPairSwapHandler(_oracle) DCAPairPositionHandler(_tokenA, _tokenB) {}\n}\n"
    },
    "contracts/interfaces/IERC20Detailed.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.4;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ninterface IERC20Detailed is IERC20 {\n  function decimals() external view returns (uint8);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/IDCAFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.4;\n\nimport './IDCAGlobalParameters.sol';\n\ninterface IDCAFactoryPairsHandler {\n  error IdenticalTokens();\n\n  error PairAlreadyExists();\n\n  event PairCreated(address indexed _token0, address indexed _token1, address _pair);\n\n  function globalParameters() external view returns (IDCAGlobalParameters);\n\n  function pairByTokens(address _tokenA, address _tokenB) external view returns (address _pair);\n\n  function allPairs(uint256 _pairIndex) external view returns (address pair);\n\n  function createPair(address _tokenA, address _tokenB) external returns (address pair);\n}\n\ninterface IDCAFactory is IDCAFactoryPairsHandler {}\n"
    },
    "contracts/interfaces/IDCAGlobalParameters.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.4;\n\nimport './IDCATokenDescriptor.sol';\n\ninterface IDCAGlobalParameters {\n  struct SwapParameters {\n    address feeRecipient;\n    bool isPaused;\n    uint32 swapFee;\n  }\n\n  struct LoanParameters {\n    address feeRecipient;\n    bool isPaused;\n    uint32 loanFee;\n  }\n\n  event FeeRecipientSet(address _feeRecipient);\n  event NFTDescriptorSet(IDCATokenDescriptor _descriptor);\n  event SwapFeeSet(uint32 _feeSet);\n  event LoanFeeSet(uint32 _feeSet);\n  event SwapIntervalsAllowed(uint32[] _swapIntervals, string[] _descriptions);\n  event SwapIntervalsForbidden(uint32[] _swapIntervals);\n\n  error HighFee();\n  error InvalidParams();\n  error ZeroInterval();\n  error EmptyDescription();\n  error AllowedInterval();\n  error InvalidInterval();\n\n  /* Public getters */\n  function feeRecipient() external view returns (address);\n\n  function swapFee() external view returns (uint32);\n\n  function loanFee() external view returns (uint32);\n\n  function nftDescriptor() external view returns (IDCATokenDescriptor);\n\n  // solhint-disable-next-line func-name-mixedcase\n  function FEE_PRECISION() external view returns (uint24);\n\n  // solhint-disable-next-line func-name-mixedcase\n  function MAX_FEE() external view returns (uint32);\n\n  function allowedSwapIntervals() external view returns (uint32[] memory __allowedSwapIntervals);\n\n  function intervalDescription(uint32 _swapInterval) external view returns (string memory);\n\n  function isSwapIntervalAllowed(uint32 _swapInterval) external view returns (bool);\n\n  function paused() external view returns (bool);\n\n  function swapParameters() external view returns (SwapParameters memory);\n\n  function loanParameters() external view returns (LoanParameters memory);\n\n  /* Public setters */\n  function setFeeRecipient(address _feeRecipient) external;\n\n  function setSwapFee(uint32 _fee) external;\n\n  function setLoanFee(uint32 _fee) external;\n\n  function setNFTDescriptor(IDCATokenDescriptor _descriptor) external;\n\n  function addSwapIntervalsToAllowedList(uint32[] calldata _swapIntervals, string[] calldata _descriptions) external;\n\n  function removeSwapIntervalsFromAllowedList(uint32[] calldata _swapIntervals) external;\n\n  function pause() external;\n\n  function unpause() external;\n}\n"
    },
    "contracts/libraries/CommonErrors.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.4;\n\nlibrary CommonErrors {\n  error ZeroAddress();\n  error Paused();\n  error InsufficientLiquidity();\n  error LiquidityNotReturned();\n}\n"
    },
    "contracts/DCAPair/DCAPairParameters.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.4;\n\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport '../interfaces/IDCAGlobalParameters.sol';\nimport '../interfaces/IERC20Detailed.sol';\nimport '../interfaces/IDCAPair.sol';\nimport '../libraries/CommonErrors.sol';\n\nimport './utils/Math.sol';\n\nabstract contract DCAPairParameters is IDCAPairParameters {\n  // Internal constants\n  uint256 internal immutable _magnitudeA;\n  uint256 internal immutable _magnitudeB;\n  uint24 internal immutable _feePrecision;\n\n  // Basic setup\n  IDCAGlobalParameters public override globalParameters;\n  IERC20Detailed public override tokenA;\n  IERC20Detailed public override tokenB;\n\n  // Tracking\n  mapping(uint32 => mapping(address => mapping(uint32 => int256))) public override swapAmountDelta; // swap interval => from token => swap number => delta\n  mapping(uint32 => uint32) public override performedSwaps; // swap interval => performed swaps\n  mapping(uint32 => mapping(address => mapping(uint32 => uint256))) internal _accumRatesPerUnit; // swap interval => from token => swap number => accum\n  mapping(address => uint256) internal _balances;\n\n  constructor(\n    IDCAGlobalParameters _globalParameters,\n    IERC20Detailed _tokenA,\n    IERC20Detailed _tokenB\n  ) {\n    if (address(_globalParameters) == address(0)) revert CommonErrors.ZeroAddress();\n    if (address(_tokenA) == address(0)) revert CommonErrors.ZeroAddress();\n    if (address(_tokenB) == address(0)) revert CommonErrors.ZeroAddress();\n    globalParameters = _globalParameters;\n    _feePrecision = globalParameters.FEE_PRECISION();\n    tokenA = _tokenA;\n    tokenB = _tokenB;\n    _magnitudeA = 10**_tokenA.decimals();\n    _magnitudeB = 10**_tokenB.decimals();\n  }\n\n  function _getFeeFromAmount(uint32 _feeAmount, uint256 _amount) internal view returns (uint256) {\n    (bool _ok, uint256 _fee) = Math.tryMul(_amount, _feeAmount);\n    if (_ok) {\n      _fee = _fee / _feePrecision / 100;\n    } else {\n      _fee = (_feeAmount < _feePrecision) ? ((_amount / _feePrecision) * _feeAmount) / 100 : (_amount / _feePrecision / 100) * _feeAmount;\n    }\n    return _fee;\n  }\n}\n"
    },
    "contracts/DCAPair/DCAPairPositionHandler.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.4;\n\nimport '@openzeppelin/contracts/token/ERC721/ERC721.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\n\nimport './DCAPairParameters.sol';\n\nabstract contract DCAPairPositionHandler is ReentrancyGuard, DCAPairParameters, IDCAPairPositionHandler, ERC721 {\n  struct DCA {\n    uint32 lastWithdrawSwap;\n    uint32 lastSwap;\n    uint32 swapInterval; // TODO: remove 32 bits from somewhere else\n    uint192 rate;\n    bool fromTokenA;\n    uint248 swappedBeforeModified;\n  }\n\n  using SafeERC20 for IERC20Detailed;\n\n  mapping(uint256 => DCA) internal _userPositions;\n  uint256 internal _idCounter;\n\n  constructor(IERC20Detailed _tokenA, IERC20Detailed _tokenB)\n    ERC721(string(abi.encodePacked('DCA: ', _tokenA.symbol(), ' - ', _tokenB.symbol())), 'DCA')\n  {}\n\n  function userPosition(uint256 _dcaId) public view override returns (UserPosition memory _userPosition) {\n    DCA memory position = _userPositions[_dcaId];\n    _userPosition.from = position.fromTokenA ? tokenA : tokenB;\n    _userPosition.to = position.fromTokenA ? tokenB : tokenA;\n    _userPosition.swapInterval = position.swapInterval;\n    _userPosition.swapsExecuted = position.swapInterval > 0 ? performedSwaps[position.swapInterval] - position.lastWithdrawSwap : 0;\n    _userPosition.swapped = _calculateSwapped(_dcaId);\n    _userPosition.swapsLeft = position.lastSwap > performedSwaps[position.swapInterval]\n      ? position.lastSwap - performedSwaps[position.swapInterval]\n      : 0;\n    _userPosition.remaining = _calculateUnswapped(_dcaId);\n    _userPosition.rate = position.rate;\n  }\n\n  function deposit(\n    address _tokenAddress,\n    uint192 _rate,\n    uint32 _amountOfSwaps,\n    uint32 _swapInterval\n  ) public override nonReentrant returns (uint256) {\n    if (_tokenAddress != address(tokenA) && _tokenAddress != address(tokenB)) revert InvalidToken();\n    if (!globalParameters.isSwapIntervalAllowed(_swapInterval)) revert InvalidInterval();\n    IERC20Detailed _from = _tokenAddress == address(tokenA) ? tokenA : tokenB;\n    uint256 _amount = _rate * _amountOfSwaps;\n    _from.safeTransferFrom(msg.sender, address(this), _amount);\n    _balances[_tokenAddress] += _amount;\n    _idCounter += 1;\n    _safeMint(msg.sender, _idCounter);\n    (uint32 _startingSwap, uint32 _finalSwap) = _addPosition(_idCounter, _tokenAddress, _rate, _amountOfSwaps, 0, _swapInterval);\n    emit Deposited(msg.sender, _idCounter, _tokenAddress, _rate, _startingSwap, _swapInterval, _finalSwap);\n    return _idCounter;\n  }\n\n  function withdrawSwapped(uint256 _dcaId) public override nonReentrant returns (uint256 _swapped) {\n    _assertPositionExistsAndCanBeOperatedByCaller(_dcaId);\n\n    _swapped = _calculateSwapped(_dcaId);\n\n    _userPositions[_dcaId].lastWithdrawSwap = performedSwaps[_userPositions[_dcaId].swapInterval];\n    _userPositions[_dcaId].swappedBeforeModified = 0;\n\n    IERC20Detailed _to = _getTo(_dcaId);\n    _balances[address(_to)] -= _swapped;\n    _to.safeTransfer(msg.sender, _swapped);\n\n    emit Withdrew(msg.sender, _dcaId, address(_to), _swapped);\n  }\n\n  function withdrawSwappedMany(uint256[] calldata _dcaIds)\n    public\n    override\n    nonReentrant\n    returns (uint256 _swappedTokenA, uint256 _swappedTokenB)\n  {\n    for (uint256 i; i < _dcaIds.length; i++) {\n      uint256 _dcaId = _dcaIds[i];\n      _assertPositionExistsAndCanBeOperatedByCaller(_dcaId);\n      uint256 _swappedDCA = _calculateSwapped(_dcaId);\n      if (_userPositions[_dcaId].fromTokenA) {\n        _swappedTokenB += _swappedDCA;\n      } else {\n        _swappedTokenA += _swappedDCA;\n      }\n      _userPositions[_dcaId].lastWithdrawSwap = performedSwaps[_userPositions[_dcaId].swapInterval];\n      _userPositions[_dcaId].swappedBeforeModified = 0;\n    }\n\n    if (_swappedTokenA > 0) {\n      _balances[address(tokenA)] -= _swappedTokenA;\n      tokenA.safeTransfer(msg.sender, _swappedTokenA);\n    }\n\n    if (_swappedTokenB > 0) {\n      _balances[address(tokenB)] -= _swappedTokenB;\n      tokenB.safeTransfer(msg.sender, _swappedTokenB);\n    }\n    emit WithdrewMany(msg.sender, _dcaIds, _swappedTokenA, _swappedTokenB);\n  }\n\n  function terminate(uint256 _dcaId) public override nonReentrant {\n    _assertPositionExistsAndCanBeOperatedByCaller(_dcaId);\n\n    uint256 _swapped = _calculateSwapped(_dcaId);\n    uint256 _unswapped = _calculateUnswapped(_dcaId);\n\n    IERC20Detailed _from = _getFrom(_dcaId);\n    IERC20Detailed _to = _getTo(_dcaId);\n    _removePosition(_dcaId);\n    _burn(_dcaId);\n\n    if (_swapped > 0) {\n      _balances[address(_to)] -= _swapped;\n      _to.safeTransfer(msg.sender, _swapped);\n    }\n\n    if (_unswapped > 0) {\n      _balances[address(_from)] -= _unswapped;\n      _from.safeTransfer(msg.sender, _unswapped);\n    }\n\n    emit Terminated(msg.sender, _dcaId, _unswapped, _swapped);\n  }\n\n  function modifyRate(uint256 _dcaId, uint192 _newRate) public override nonReentrant {\n    _assertPositionExistsAndCanBeOperatedByCaller(_dcaId);\n\n    DCA memory _userDCA = _userPositions[_dcaId];\n\n    uint32 _swapsLeft = _userDCA.lastSwap - performedSwaps[_userDCA.swapInterval];\n    if (_swapsLeft == 0) revert PositionCompleted();\n\n    _modifyRateAndSwaps(_dcaId, _newRate, _swapsLeft);\n  }\n\n  function modifySwaps(uint256 _dcaId, uint32 _newSwaps) public override nonReentrant {\n    _assertPositionExistsAndCanBeOperatedByCaller(_dcaId);\n\n    _modifyRateAndSwaps(_dcaId, _userPositions[_dcaId].rate, _newSwaps);\n  }\n\n  function modifyRateAndSwaps(\n    uint256 _dcaId,\n    uint192 _newRate,\n    uint32 _newAmountOfSwaps\n  ) public override nonReentrant {\n    _assertPositionExistsAndCanBeOperatedByCaller(_dcaId);\n\n    _modifyRateAndSwaps(_dcaId, _newRate, _newAmountOfSwaps);\n  }\n\n  function addFundsToPosition(\n    uint256 _dcaId,\n    uint256 _amount,\n    uint32 _newSwaps\n  ) public override nonReentrant {\n    _assertPositionExistsAndCanBeOperatedByCaller(_dcaId);\n    if (_amount == 0) revert ZeroAmount();\n\n    uint256 _unswapped = _calculateUnswapped(_dcaId);\n    uint256 _total = _unswapped + _amount;\n\n    _modifyPosition(_dcaId, _total, _unswapped, uint192(_total / _newSwaps), _newSwaps);\n  }\n\n  function tokenURI(uint256 tokenId) public view override returns (string memory) {\n    return globalParameters.nftDescriptor().tokenURI(this, tokenId);\n  }\n\n  /** Helper function to modify a position */\n  function _modifyRateAndSwaps(\n    uint256 _dcaId,\n    uint192 _newRate,\n    uint32 _newAmountOfSwaps\n  ) internal {\n    uint256 _unswapped = _calculateUnswapped(_dcaId);\n    uint256 _totalNecessary = _newRate * _newAmountOfSwaps;\n\n    _modifyPosition(_dcaId, _totalNecessary, _unswapped, _newRate, _newAmountOfSwaps);\n  }\n\n  function _modifyPosition(\n    uint256 _dcaId,\n    uint256 _totalNecessary,\n    uint256 _unswapped,\n    uint192 _newRate,\n    uint32 _newAmountOfSwaps\n  ) internal {\n    IERC20Detailed _from = _getFrom(_dcaId);\n\n    // We will store the swapped amount without the fee. The fee will be applied during withdraw/terminate\n    uint256 _swapped = _calculateSwapped(_dcaId, false);\n    if (_swapped > type(uint248).max) revert MandatoryWithdraw(); // You should withdraw before modifying, to avoid loosing funds\n\n    uint32 _swapInterval = _userPositions[_dcaId].swapInterval;\n    _removePosition(_dcaId);\n    (uint32 _startingSwap, uint32 _finalSwap) = _addPosition(\n      _dcaId,\n      address(_from),\n      _newRate,\n      _newAmountOfSwaps,\n      uint248(_swapped),\n      _swapInterval\n    );\n\n    if (_totalNecessary > _unswapped) {\n      // We need to ask for more funds\n      _from.safeTransferFrom(msg.sender, address(this), _totalNecessary - _unswapped);\n      _balances[address(_from)] += _totalNecessary - _unswapped;\n    } else if (_totalNecessary < _unswapped) {\n      // We need to return to the owner the amount that won't be used anymore\n      _balances[address(_from)] -= _unswapped - _totalNecessary;\n      _from.safeTransfer(msg.sender, _unswapped - _totalNecessary);\n    }\n\n    emit Modified(msg.sender, _dcaId, _newRate, _startingSwap, _finalSwap);\n  }\n\n  function _assertPositionExistsAndCanBeOperatedByCaller(uint256 _dcaId) internal view {\n    if (_userPositions[_dcaId].rate == 0) revert InvalidPosition();\n    if (!_isApprovedOrOwner(msg.sender, _dcaId)) revert UnauthorizedCaller();\n  }\n\n  function _addPosition(\n    uint256 _dcaId,\n    address _from,\n    uint192 _rate,\n    uint32 _amountOfSwaps,\n    uint248 _swappedBeforeModified,\n    uint32 _swapInterval\n  ) internal returns (uint32 _startingSwap, uint32 _finalSwap) {\n    if (_rate == 0) revert ZeroRate();\n    if (_amountOfSwaps == 0) revert ZeroSwaps();\n    uint32 _performedSwaps = performedSwaps[_swapInterval];\n    _startingSwap = _performedSwaps + 1;\n    _finalSwap = _performedSwaps + _amountOfSwaps;\n    swapAmountDelta[_swapInterval][_from][_startingSwap] += int192(_rate);\n    swapAmountDelta[_swapInterval][_from][_finalSwap] -= int192(_rate);\n    _userPositions[_dcaId] = DCA(_performedSwaps, _finalSwap, _swapInterval, _rate, _from == address(tokenA), _swappedBeforeModified);\n  }\n\n  function _removePosition(uint256 _dcaId) internal {\n    DCA memory _userDCA = _userPositions[_dcaId];\n    if (_userDCA.lastSwap > performedSwaps[_userDCA.swapInterval]) {\n      address _from = _userDCA.fromTokenA ? address(tokenA) : address(tokenB);\n      swapAmountDelta[_userDCA.swapInterval][_from][performedSwaps[_userDCA.swapInterval] + 1] -= int192(_userDCA.rate);\n      swapAmountDelta[_userDCA.swapInterval][_from][_userDCA.lastSwap] += int192(_userDCA.rate);\n    }\n    delete _userPositions[_dcaId];\n  }\n\n  /** Return the amount of tokens swapped in TO */\n  function _calculateSwapped(uint256 _dcaId) internal view returns (uint256 _swapped) {\n    _swapped = _calculateSwapped(_dcaId, true);\n  }\n\n  function _calculateSwapped(uint256 _dcaId, bool _applyFee) internal view returns (uint256 _swapped) {\n    DCA memory _userDCA = _userPositions[_dcaId];\n    address _from = _userDCA.fromTokenA ? address(tokenA) : address(tokenB);\n    uint256 _accumRatesLastWidthraw = _accumRatesPerUnit[_userDCA.swapInterval][_from][_userDCA.lastWithdrawSwap];\n    uint256 _accumRatesLastSwap = _accumRatesPerUnit[_userDCA.swapInterval][_from][\n      performedSwaps[_userDCA.swapInterval] < _userDCA.lastSwap ? performedSwaps[_userDCA.swapInterval] : _userDCA.lastSwap\n    ];\n\n    uint256 _accumPerUnit = _accumRatesLastSwap - _accumRatesLastWidthraw;\n    uint256 _magnitude = _userDCA.fromTokenA ? _magnitudeA : _magnitudeB;\n    (bool _ok, uint256 _mult) = Math.tryMul(_accumPerUnit, _userDCA.rate);\n    uint256 _swappedInCurrentPosition;\n    if (_ok) {\n      _swappedInCurrentPosition = _mult / _magnitude;\n    } else {\n      // Since we can't multiply accum and rate because of overflows, we need to figure out which to divide\n      // We don't want to divide a term that is smaller than magnitude, because it would go to 0.\n      // And if neither are smaller than magnitude, then we will choose the one that loses less information, and that would be the one with smallest reminder\n      bool _divideAccumFirst = _userDCA.rate < _magnitude ||\n        (_accumPerUnit > _magnitude && _accumPerUnit % _magnitude < _userDCA.rate % _magnitude);\n      _swappedInCurrentPosition = _divideAccumFirst\n        ? (_accumPerUnit / _magnitude) * _userDCA.rate\n        : (_userDCA.rate / _magnitude) * _accumPerUnit;\n    }\n\n    uint256 _actuallySwapped = _swappedInCurrentPosition + _userDCA.swappedBeforeModified;\n    if (_applyFee) {\n      _swapped = _actuallySwapped - _getFeeFromAmount(globalParameters.swapFee(), _actuallySwapped);\n    } else {\n      _swapped = _actuallySwapped;\n    }\n  }\n\n  /** Returns how many FROM remains unswapped  */\n  function _calculateUnswapped(uint256 _dcaId) internal view returns (uint256 _unswapped) {\n    DCA memory _userDCA = _userPositions[_dcaId];\n    if (_userDCA.lastSwap <= performedSwaps[_userDCA.swapInterval]) {\n      return 0;\n    }\n    uint32 _remainingSwaps = _userDCA.lastSwap - performedSwaps[_userDCA.swapInterval];\n    _unswapped = _remainingSwaps * _userDCA.rate;\n  }\n\n  function _getFrom(uint256 _dcaId) internal view returns (IERC20Detailed _from) {\n    DCA memory _userDCA = _userPositions[_dcaId];\n    _from = _userDCA.fromTokenA ? tokenA : tokenB;\n  }\n\n  function _getTo(uint256 _dcaId) internal view returns (IERC20Detailed _to) {\n    DCA memory _userDCA = _userPositions[_dcaId];\n    _to = _userDCA.fromTokenA ? tokenB : tokenA;\n  }\n}\n"
    },
    "contracts/DCAPair/DCAPairSwapHandler.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.4;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\n\nimport '../interfaces/ISlidingOracle.sol';\nimport '../interfaces/IDCAPairSwapCallee.sol';\nimport '../libraries/CommonErrors.sol';\n\nimport './DCAPairParameters.sol';\n\nabstract contract DCAPairSwapHandler is ReentrancyGuard, DCAPairParameters, IDCAPairSwapHandler {\n  using SafeERC20 for IERC20Detailed;\n\n  mapping(uint32 => mapping(address => uint256)) public override swapAmountAccumulator; // swap interval => from token => swap amount accum\n\n  mapping(uint32 => uint32) public override lastSwapPerformed;\n  ISlidingOracle public override oracle;\n\n  constructor(ISlidingOracle _oracle) {\n    if (address(_oracle) == address(0)) revert CommonErrors.ZeroAddress();\n    oracle = _oracle;\n  }\n\n  function _addNewRatePerUnit(\n    uint32 _swapInterval,\n    address _address,\n    uint32 _performedSwap,\n    uint256 _ratePerUnit\n  ) internal {\n    uint256 _accumRatesPerUnitPreviousSwap = _accumRatesPerUnit[_swapInterval][_address][_performedSwap - 1];\n    _accumRatesPerUnit[_swapInterval][_address][_performedSwap] = _accumRatesPerUnitPreviousSwap + _ratePerUnit;\n  }\n\n  function _registerSwap(\n    uint32 _swapInterval,\n    address _token,\n    uint256 _internalAmountUsedToSwap,\n    uint256 _ratePerUnit,\n    uint32 _swapToRegister\n  ) internal {\n    swapAmountAccumulator[_swapInterval][_token] = _internalAmountUsedToSwap;\n    _addNewRatePerUnit(_swapInterval, _token, _swapToRegister, _ratePerUnit);\n    delete swapAmountDelta[_swapInterval][_token][_swapToRegister];\n  }\n\n  function _getAmountToSwap(\n    uint32 _swapInterval,\n    address _address,\n    uint32 _swapToPerform\n  ) internal view returns (uint256 _swapAmountAccumulator) {\n    unchecked {\n      _swapAmountAccumulator =\n        swapAmountAccumulator[_swapInterval][_address] +\n        uint256(swapAmountDelta[_swapInterval][_address][_swapToPerform]);\n    }\n  }\n\n  function _convertTo(\n    uint256 _fromTokenMagnitude,\n    uint256 _amountFrom,\n    uint256 _rateFromTo\n  ) internal pure returns (uint256 _amountTo) {\n    _amountTo = (_amountFrom * _rateFromTo) / _fromTokenMagnitude;\n  }\n\n  function getNextSwapInfo(uint32 _swapInterval) public view override returns (NextSwapInformation memory _nextSwapInformation) {\n    uint32 _swapFee = globalParameters.swapFee();\n    _nextSwapInformation = _getNextSwapInfo(_swapInterval, _swapFee);\n  }\n\n  function _getNextSwapInfo(uint32 _swapInterval, uint32 _swapFee) internal view returns (NextSwapInformation memory _nextSwapInformation) {\n    _nextSwapInformation.swapToPerform = performedSwaps[_swapInterval] + 1;\n    _nextSwapInformation.amountToSwapTokenA = _getAmountToSwap(_swapInterval, address(tokenA), _nextSwapInformation.swapToPerform);\n    _nextSwapInformation.amountToSwapTokenB = _getAmountToSwap(_swapInterval, address(tokenB), _nextSwapInformation.swapToPerform);\n    // TODO: Instead of using current, it should use quote to get a moving average and not current?\n    _nextSwapInformation.ratePerUnitBToA = oracle.current(address(tokenB), _magnitudeB, address(tokenA));\n    _nextSwapInformation.ratePerUnitAToB = (_magnitudeB * _magnitudeA) / _nextSwapInformation.ratePerUnitBToA;\n\n    uint256 _amountOfTokenAIfTokenBSwapped = _convertTo(\n      _magnitudeB,\n      _nextSwapInformation.amountToSwapTokenB,\n      _nextSwapInformation.ratePerUnitBToA\n    );\n\n    if (_amountOfTokenAIfTokenBSwapped < _nextSwapInformation.amountToSwapTokenA) {\n      _nextSwapInformation.tokenToBeProvidedBySwapper = tokenB;\n      _nextSwapInformation.tokenToRewardSwapperWith = tokenA;\n      uint256 _tokenASurplus = _nextSwapInformation.amountToSwapTokenA - _amountOfTokenAIfTokenBSwapped;\n      _nextSwapInformation.amountToBeProvidedBySwapper = _convertTo(_magnitudeA, _tokenASurplus, _nextSwapInformation.ratePerUnitAToB);\n      _nextSwapInformation.amountToRewardSwapperWith = _tokenASurplus + _getFeeFromAmount(_swapFee, _tokenASurplus);\n      _nextSwapInformation.platformFeeTokenA = _getFeeFromAmount(_swapFee, _amountOfTokenAIfTokenBSwapped);\n      _nextSwapInformation.platformFeeTokenB = _getFeeFromAmount(_swapFee, _nextSwapInformation.amountToSwapTokenB);\n      _nextSwapInformation.availableToBorrowTokenA = _balances[address(tokenA)] - _nextSwapInformation.amountToRewardSwapperWith;\n      _nextSwapInformation.availableToBorrowTokenB = _balances[address(tokenB)];\n    } else if (_amountOfTokenAIfTokenBSwapped > _nextSwapInformation.amountToSwapTokenA) {\n      _nextSwapInformation.tokenToBeProvidedBySwapper = tokenA;\n      _nextSwapInformation.tokenToRewardSwapperWith = tokenB;\n      _nextSwapInformation.amountToBeProvidedBySwapper = _amountOfTokenAIfTokenBSwapped - _nextSwapInformation.amountToSwapTokenA;\n      uint256 _amountToBeProvidedConvertedToB = _convertTo(\n        _magnitudeA,\n        _nextSwapInformation.amountToBeProvidedBySwapper,\n        _nextSwapInformation.ratePerUnitAToB\n      );\n      _nextSwapInformation.amountToRewardSwapperWith =\n        _amountToBeProvidedConvertedToB +\n        _getFeeFromAmount(_swapFee, _amountToBeProvidedConvertedToB);\n      _nextSwapInformation.platformFeeTokenA = _getFeeFromAmount(_swapFee, _nextSwapInformation.amountToSwapTokenA);\n      _nextSwapInformation.platformFeeTokenB = _getFeeFromAmount(\n        _swapFee,\n        _nextSwapInformation.amountToSwapTokenB - _amountToBeProvidedConvertedToB\n      );\n      _nextSwapInformation.availableToBorrowTokenA = _balances[address(tokenA)];\n      _nextSwapInformation.availableToBorrowTokenB = _balances[address(tokenB)] - _nextSwapInformation.amountToRewardSwapperWith;\n    } else {\n      _nextSwapInformation.platformFeeTokenA = _getFeeFromAmount(_swapFee, _nextSwapInformation.amountToSwapTokenA);\n      _nextSwapInformation.platformFeeTokenB = _getFeeFromAmount(_swapFee, _nextSwapInformation.amountToSwapTokenB);\n      _nextSwapInformation.availableToBorrowTokenA = _balances[address(tokenA)];\n      _nextSwapInformation.availableToBorrowTokenB = _balances[address(tokenB)];\n    }\n  }\n\n  function swap(uint32 _swapInterval) public override {\n    swap(_swapInterval, 0, 0, msg.sender, '');\n  }\n\n  function swap(\n    uint32 _swapInterval,\n    uint256 _amountToBorrowTokenA,\n    uint256 _amountToBorrowTokenB,\n    address _to,\n    bytes memory _data\n  ) public override nonReentrant {\n    IDCAGlobalParameters.SwapParameters memory _swapParameters = globalParameters.swapParameters();\n    if (_swapParameters.isPaused) revert CommonErrors.Paused();\n    if (lastSwapPerformed[_swapInterval] / _swapInterval >= _getTimestamp() / _swapInterval) revert WithinInterval();\n    NextSwapInformation memory _nextSwapInformation = _getNextSwapInfo(_swapInterval, _swapParameters.swapFee);\n    _registerSwap(\n      _swapInterval,\n      address(tokenA),\n      _nextSwapInformation.amountToSwapTokenA,\n      _nextSwapInformation.ratePerUnitAToB,\n      _nextSwapInformation.swapToPerform\n    );\n    _registerSwap(\n      _swapInterval,\n      address(tokenB),\n      _nextSwapInformation.amountToSwapTokenB,\n      _nextSwapInformation.ratePerUnitBToA,\n      _nextSwapInformation.swapToPerform\n    );\n    performedSwaps[_swapInterval] = _nextSwapInformation.swapToPerform;\n    lastSwapPerformed[_swapInterval] = _getTimestamp();\n\n    if (\n      _amountToBorrowTokenA > _nextSwapInformation.availableToBorrowTokenA ||\n      _amountToBorrowTokenB > _nextSwapInformation.availableToBorrowTokenB\n    ) revert CommonErrors.InsufficientLiquidity();\n\n    uint256 _amountToHaveTokenA = _nextSwapInformation.availableToBorrowTokenA;\n    uint256 _amountToHaveTokenB = _nextSwapInformation.availableToBorrowTokenB;\n\n    {\n      // scope for _amountToSendToken{A,B}, avoids stack too deep errors\n      uint256 _amountToSendTokenA = _amountToBorrowTokenA;\n      uint256 _amountToSendTokenB = _amountToBorrowTokenB;\n\n      if (_nextSwapInformation.tokenToRewardSwapperWith == tokenA) {\n        _amountToSendTokenA += _nextSwapInformation.amountToRewardSwapperWith;\n        _amountToHaveTokenB += _nextSwapInformation.amountToBeProvidedBySwapper;\n      } else {\n        _amountToSendTokenB += _nextSwapInformation.amountToRewardSwapperWith;\n        _amountToHaveTokenA += _nextSwapInformation.amountToBeProvidedBySwapper;\n      }\n\n      // Optimistically transfer tokens\n      if (_amountToSendTokenA > 0) tokenA.safeTransfer(_to, _amountToSendTokenA);\n      if (_amountToSendTokenB > 0) tokenB.safeTransfer(_to, _amountToSendTokenB);\n    }\n\n    if (_data.length > 0) {\n      // Make call\n      IDCAPairSwapCallee(_to).DCAPairSwapCall(\n        msg.sender,\n        tokenA,\n        tokenB,\n        _amountToBorrowTokenA,\n        _amountToBorrowTokenB,\n        _nextSwapInformation.tokenToRewardSwapperWith == tokenA,\n        _nextSwapInformation.amountToRewardSwapperWith,\n        _nextSwapInformation.amountToBeProvidedBySwapper,\n        _data\n      );\n    }\n\n    uint256 _balanceTokenA = tokenA.balanceOf(address(this));\n    uint256 _balanceTokenB = tokenB.balanceOf(address(this));\n\n    // Make sure that they sent the tokens back\n    if (_balanceTokenA < _amountToHaveTokenA || _balanceTokenB < _amountToHaveTokenB) revert CommonErrors.LiquidityNotReturned();\n\n    // Update balances\n    _balances[address(tokenA)] = _balanceTokenA - _nextSwapInformation.platformFeeTokenA;\n    _balances[address(tokenB)] = _balanceTokenB - _nextSwapInformation.platformFeeTokenB;\n\n    // Send fees\n    tokenA.safeTransfer(_swapParameters.feeRecipient, _nextSwapInformation.platformFeeTokenA);\n    tokenB.safeTransfer(_swapParameters.feeRecipient, _nextSwapInformation.platformFeeTokenB);\n\n    // Emit event\n    emit Swapped(msg.sender, _to, _amountToBorrowTokenA, _amountToBorrowTokenB, _nextSwapInformation);\n  }\n\n  function _getTimestamp() internal view virtual returns (uint32 _blockTimestamp) {\n    _blockTimestamp = uint32(block.timestamp);\n  }\n}\n"
    },
    "contracts/DCAPair/DCAPairLoanHandler.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.4;\n\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\n\nimport '../interfaces/IDCAPairLoanCallee.sol';\nimport '../libraries/CommonErrors.sol';\n\nimport './DCAPairParameters.sol';\n\nabstract contract DCAPairLoanHandler is ReentrancyGuard, DCAPairParameters, IDCAPairLoanHandler {\n  using SafeERC20 for IERC20Detailed;\n\n  function loan(\n    uint256 _amountToBorrowTokenA,\n    uint256 _amountToBorrowTokenB,\n    address _to,\n    bytes memory _data\n  ) public override nonReentrant {\n    if (_amountToBorrowTokenA == 0 && _amountToBorrowTokenB == 0) revert ZeroLoan();\n\n    IDCAGlobalParameters.LoanParameters memory _loanParameters = globalParameters.loanParameters();\n\n    if (_loanParameters.isPaused) revert CommonErrors.Paused();\n\n    uint256 _beforeBalanceTokenA = _balances[address(tokenA)];\n    uint256 _beforeBalanceTokenB = _balances[address(tokenB)];\n\n    if (_amountToBorrowTokenA > _beforeBalanceTokenA || _amountToBorrowTokenB > _beforeBalanceTokenB)\n      revert CommonErrors.InsufficientLiquidity();\n\n    // Calculate fees\n    uint256 _feeTokenA = _amountToBorrowTokenA > 0 ? _getFeeFromAmount(_loanParameters.loanFee, _amountToBorrowTokenA) : 0;\n    uint256 _feeTokenB = _amountToBorrowTokenB > 0 ? _getFeeFromAmount(_loanParameters.loanFee, _amountToBorrowTokenB) : 0;\n\n    if (_amountToBorrowTokenA > 0) tokenA.safeTransfer(_to, _amountToBorrowTokenA);\n    if (_amountToBorrowTokenB > 0) tokenB.safeTransfer(_to, _amountToBorrowTokenB);\n\n    // Make call\n    IDCAPairLoanCallee(_to).DCAPairLoanCall(\n      msg.sender,\n      tokenA,\n      tokenB,\n      _amountToBorrowTokenA,\n      _amountToBorrowTokenB,\n      _feeTokenA,\n      _feeTokenB,\n      _data\n    );\n\n    uint256 _afterBalanceTokenA = tokenA.balanceOf(address(this));\n    uint256 _afterBalanceTokenB = tokenB.balanceOf(address(this));\n\n    // Make sure that they sent the tokens back\n    if (_afterBalanceTokenA < (_beforeBalanceTokenA + _feeTokenA) || _afterBalanceTokenB < (_beforeBalanceTokenB + _feeTokenB))\n      revert CommonErrors.LiquidityNotReturned();\n\n    // Update balances\n    _balances[address(tokenA)] = _afterBalanceTokenA - _feeTokenA;\n    _balances[address(tokenB)] = _afterBalanceTokenB - _feeTokenB;\n\n    // Send fees\n    tokenA.safeTransfer(_loanParameters.feeRecipient, _feeTokenA);\n    tokenB.safeTransfer(_loanParameters.feeRecipient, _feeTokenB);\n\n    // Emit event\n    emit Loaned(msg.sender, _to, _amountToBorrowTokenA, _amountToBorrowTokenB, _loanParameters.loanFee);\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The defaut value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        _balances[account] = accountBalance - amount;\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IDCAPair.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.4;\n\nimport './IDCAGlobalParameters.sol';\nimport './IERC20Detailed.sol';\nimport './ISlidingOracle.sol';\n\ninterface IDCAPairParameters {\n  /* Public getters */\n  function globalParameters() external view returns (IDCAGlobalParameters);\n\n  function tokenA() external view returns (IERC20Detailed);\n\n  function tokenB() external view returns (IERC20Detailed);\n\n  function swapAmountDelta(\n    uint32,\n    address,\n    uint32\n  ) external view returns (int256);\n\n  function performedSwaps(uint32) external view returns (uint32);\n}\n\ninterface IDCAPairPositionHandler is IDCAPairParameters {\n  struct UserPosition {\n    IERC20Detailed from;\n    IERC20Detailed to;\n    uint32 swapInterval;\n    uint32 swapsExecuted; // Since deposit or last withdraw\n    uint256 swapped; // Since deposit or last withdraw\n    uint32 swapsLeft;\n    uint256 remaining;\n    uint192 rate;\n  }\n\n  event Terminated(address indexed _user, uint256 _dcaId, uint256 _returnedUnswapped, uint256 _returnedSwapped);\n  event Deposited(\n    address indexed _user,\n    uint256 _dcaId,\n    address _fromToken,\n    uint192 _rate,\n    uint32 _startingSwap,\n    uint32 _swapInterval,\n    uint32 _lastSwap\n  );\n  event Withdrew(address indexed _user, uint256 _dcaId, address _token, uint256 _amount);\n  event WithdrewMany(address indexed _user, uint256[] _dcaIds, uint256 _swappedTokenA, uint256 _swappedTokenB);\n  event Modified(address indexed _user, uint256 _dcaId, uint192 _rate, uint32 _startingSwap, uint32 _lastSwap);\n\n  error InvalidToken();\n  error InvalidInterval();\n  error InvalidPosition();\n  error UnauthorizedCaller();\n  error ZeroRate();\n  error ZeroSwaps();\n  error ZeroAmount();\n  error PositionCompleted();\n  error MandatoryWithdraw();\n\n  function userPosition(uint256) external view returns (UserPosition memory _position);\n\n  function deposit(\n    address _tokenAddress,\n    uint192 _rate,\n    uint32 _amountOfSwaps,\n    uint32 _swapInterval\n  ) external returns (uint256 _dcaId);\n\n  function withdrawSwapped(uint256 _dcaId) external returns (uint256 _swapped);\n\n  function withdrawSwappedMany(uint256[] calldata _dcaIds) external returns (uint256 _swappedTokenA, uint256 _swappedTokenB);\n\n  function modifyRate(uint256 _dcaId, uint192 _newRate) external;\n\n  function modifySwaps(uint256 _dcaId, uint32 _newSwaps) external;\n\n  function modifyRateAndSwaps(\n    uint256 _dcaId,\n    uint192 _newRate,\n    uint32 _newSwaps\n  ) external;\n\n  function addFundsToPosition(\n    uint256 _dcaId,\n    uint256 _amount,\n    uint32 _newSwaps\n  ) external;\n\n  function terminate(uint256 _dcaId) external;\n}\n\ninterface IDCAPairSwapHandler {\n  struct NextSwapInformation {\n    uint32 swapToPerform;\n    uint256 amountToSwapTokenA;\n    uint256 amountToSwapTokenB;\n    uint256 availableToBorrowTokenA;\n    uint256 availableToBorrowTokenB;\n    uint256 ratePerUnitBToA;\n    uint256 ratePerUnitAToB;\n    uint256 platformFeeTokenA;\n    uint256 platformFeeTokenB;\n    uint256 amountToBeProvidedBySwapper;\n    uint256 amountToRewardSwapperWith;\n    IERC20Detailed tokenToBeProvidedBySwapper;\n    IERC20Detailed tokenToRewardSwapperWith;\n  }\n\n  event Swapped(\n    address indexed _sender,\n    address indexed _to,\n    uint256 _amountBorrowedTokenA,\n    uint256 _amountBorrowedTokenB,\n    NextSwapInformation _nextSwapInformation\n  );\n\n  error WithinInterval();\n\n  function lastSwapPerformed(uint32) external view returns (uint32);\n\n  function swapAmountAccumulator(uint32, address) external view returns (uint256);\n\n  function oracle() external returns (ISlidingOracle);\n\n  function getNextSwapInfo(uint32 _swapInterval) external view returns (NextSwapInformation memory _nextSwapInformation);\n\n  function swap(uint32 _swapInterval) external;\n\n  function swap(\n    uint32 _swapInterval,\n    uint256 _amountToBorrowTokenA,\n    uint256 _amountToBorrowTokenB,\n    address _to,\n    bytes calldata _data\n  ) external;\n}\n\ninterface IDCAPairLoanHandler {\n  event Loaned(address indexed _sender, address indexed _to, uint256 _amountBorrowedTokenA, uint256 _amountBorrowedTokenB, uint32 _loanFee);\n\n  error ZeroLoan();\n\n  function loan(\n    uint256 _amountToBorrowTokenA,\n    uint256 _amountToBorrowTokenB,\n    address _to,\n    bytes memory _data\n  ) external;\n}\n\ninterface IDCAPair is IDCAPairParameters, IDCAPairSwapHandler, IDCAPairPositionHandler, IDCAPairLoanHandler {}\n"
    },
    "contracts/DCAPair/utils/Math.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.4;\n\nlibrary Math {\n  function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    unchecked {\n      // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n      // benefit is lost if 'b' is also tested.\n      // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n      if (a == 0) return (true, 0);\n      uint256 c = a * b;\n      if (c / a != b) return (false, 0);\n      return (true, c);\n    }\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IDCATokenDescriptor.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.4;\n\nimport './IDCAPair.sol';\n\ninterface IDCATokenDescriptor {\n  function tokenURI(IDCAPairPositionHandler _positionHandler, uint256 _tokenId) external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/ISlidingOracle.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.4;\n\ninterface ISlidingOracle {\n  function current(\n    address _tokenIn,\n    uint256 _amountIn,\n    address _tokenOut\n  ) external view returns (uint256 _amountOut);\n\n  function quote(\n    address _tokenIn,\n    uint256 _amountIn,\n    address _tokenOut,\n    uint256 _granularity\n  ) external view returns (uint256 _amountOut);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping (uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping (address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC721).interfaceId\n            || interfaceId == type(IERC721Metadata).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0\n            ? string(abi.encodePacked(baseURI, tokenId.toString()))\n            : '';\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. Empty by default, can be overriden\n     * in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\n\n        _operatorApprovals[_msgSender()][operator] = approved;\n        emit ApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        private returns (bool)\n    {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver(to).onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    // solhint-disable-next-line no-inline-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from` cannot be the zero address.\n      * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant alphabet = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = alphabet[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IDCAPairSwapCallee.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.4;\n\nimport './IERC20Detailed.sol';\n\ninterface IDCAPairSwapCallee {\n  // solhint-disable-next-line func-name-mixedcase\n  function DCAPairSwapCall(\n    address _sender,\n    IERC20Detailed _tokenA,\n    IERC20Detailed _tokenB,\n    uint256 _amountBorrowedTokenA,\n    uint256 _amountBorrowedTokenB,\n    bool _isRewardTokenA,\n    uint256 _rewardAmount,\n    uint256 _amountToProvide,\n    bytes calldata _data\n  ) external;\n}\n"
    },
    "contracts/interfaces/IDCAPairLoanCallee.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.4;\n\nimport './IERC20Detailed.sol';\n\ninterface IDCAPairLoanCallee {\n  // solhint-disable-next-line func-name-mixedcase\n  function DCAPairLoanCall(\n    address _sender,\n    IERC20Detailed _tokenA,\n    IERC20Detailed _tokenB,\n    uint256 _amountBorrowedTokenA,\n    uint256 _amountBorrowedTokenB,\n    uint256 _feeTokenA,\n    uint256 _feeTokenB,\n    bytes calldata _data\n  ) external;\n}\n"
    },
    "contracts/mocks/DCAFactory/DCAFactoryPairsHandler.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.4;\n\nimport '../../DCAFactory/DCAFactoryPairsHandler.sol';\n\ncontract DCAFactoryPairsHandlerMock is DCAFactoryPairsHandler {\n  constructor(IDCAGlobalParameters _globalParameters) DCAFactoryPairsHandler(_globalParameters) {}\n\n  function sortTokens(address _tokenA, address _tokenB) public pure returns (address _token0, address _token1) {\n    (_token0, _token1) = _sortTokens(_tokenA, _tokenB);\n  }\n}\n"
    },
    "contracts/mocks/DCAFactory/DCAFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.4;\n\nimport './DCAFactoryPairsHandler.sol';\n\ncontract DCAFactoryMock is DCAFactoryPairsHandlerMock, IDCAFactory {\n  constructor(IDCAGlobalParameters _globalParameters) DCAFactoryPairsHandlerMock(_globalParameters) {}\n}\n"
    },
    "contracts/DCAGlobalParameters/DCAGlobalParameters.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.4;\n\nimport '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport '@openzeppelin/contracts/security/Pausable.sol';\n\nimport '../utils/Governable.sol';\nimport '../interfaces/IDCAGlobalParameters.sol';\nimport '../libraries/CommonErrors.sol';\n\ncontract DCAGlobalParameters is IDCAGlobalParameters, Governable, Pausable {\n  using EnumerableSet for EnumerableSet.UintSet;\n\n  address public override feeRecipient;\n  IDCATokenDescriptor public override nftDescriptor;\n  uint32 public override swapFee = 3000; // 0.3%\n  uint32 public override loanFee = 1000; // 0.1%\n  uint24 public constant override FEE_PRECISION = 10000;\n  uint32 public constant override MAX_FEE = 10 * FEE_PRECISION; // 10%\n  mapping(uint32 => string) public override intervalDescription;\n  EnumerableSet.UintSet internal _allowedSwapIntervals;\n\n  constructor(\n    address _governor,\n    address _feeRecipient,\n    IDCATokenDescriptor _nftDescriptor\n  ) Governable(_governor) {\n    if (_feeRecipient == address(0)) revert CommonErrors.ZeroAddress();\n    if (address(_nftDescriptor) == address(0)) revert CommonErrors.ZeroAddress();\n    feeRecipient = _feeRecipient;\n    nftDescriptor = _nftDescriptor;\n  }\n\n  function setFeeRecipient(address _feeRecipient) public override onlyGovernor {\n    if (_feeRecipient == address(0)) revert CommonErrors.ZeroAddress();\n    feeRecipient = _feeRecipient;\n    emit FeeRecipientSet(_feeRecipient);\n  }\n\n  function setNFTDescriptor(IDCATokenDescriptor _descriptor) public override onlyGovernor {\n    if (address(_descriptor) == address(0)) revert CommonErrors.ZeroAddress();\n    nftDescriptor = _descriptor;\n    emit NFTDescriptorSet(_descriptor);\n  }\n\n  function setSwapFee(uint32 _swapFee) public override onlyGovernor {\n    if (_swapFee > MAX_FEE) revert HighFee();\n    swapFee = _swapFee;\n    emit SwapFeeSet(_swapFee);\n  }\n\n  function setLoanFee(uint32 _loanFee) public override onlyGovernor {\n    if (_loanFee > MAX_FEE) revert HighFee();\n    loanFee = _loanFee;\n    emit LoanFeeSet(_loanFee);\n  }\n\n  function addSwapIntervalsToAllowedList(uint32[] calldata _swapIntervals, string[] calldata _descriptions) public override onlyGovernor {\n    if (_swapIntervals.length != _descriptions.length) revert InvalidParams();\n    for (uint256 i; i < _swapIntervals.length; i++) {\n      if (_swapIntervals[i] == 0) revert ZeroInterval();\n      if (bytes(_descriptions[i]).length == 0) revert EmptyDescription();\n      if (isSwapIntervalAllowed(_swapIntervals[i])) revert AllowedInterval();\n      _allowedSwapIntervals.add(_swapIntervals[i]);\n      intervalDescription[_swapIntervals[i]] = _descriptions[i];\n    }\n    emit SwapIntervalsAllowed(_swapIntervals, _descriptions);\n  }\n\n  function removeSwapIntervalsFromAllowedList(uint32[] calldata _swapIntervals) public override onlyGovernor {\n    for (uint256 i; i < _swapIntervals.length; i++) {\n      if (!isSwapIntervalAllowed(_swapIntervals[i])) revert InvalidInterval();\n      _allowedSwapIntervals.remove(_swapIntervals[i]);\n      delete intervalDescription[_swapIntervals[i]];\n    }\n    emit SwapIntervalsForbidden(_swapIntervals);\n  }\n\n  function allowedSwapIntervals() external view override returns (uint32[] memory __allowedSwapIntervals) {\n    uint256 _allowedSwapIntervalsLength = _allowedSwapIntervals.length();\n    __allowedSwapIntervals = new uint32[](_allowedSwapIntervalsLength);\n    for (uint256 i; i < _allowedSwapIntervalsLength; i++) {\n      __allowedSwapIntervals[i] = uint32(_allowedSwapIntervals.at(i));\n    }\n  }\n\n  function isSwapIntervalAllowed(uint32 _swapInterval) public view override returns (bool) {\n    return _allowedSwapIntervals.contains(_swapInterval);\n  }\n\n  function paused() public view override(IDCAGlobalParameters, Pausable) returns (bool) {\n    return super.paused();\n  }\n\n  function pause() public override onlyGovernor {\n    _pause();\n  }\n\n  function unpause() public override onlyGovernor {\n    _unpause();\n  }\n\n  function loanParameters() public view override returns (LoanParameters memory _loanParameters) {\n    _loanParameters.feeRecipient = feeRecipient;\n    _loanParameters.isPaused = paused();\n    _loanParameters.loanFee = loanFee;\n  }\n\n  function swapParameters() public view override returns (SwapParameters memory _swapParameters) {\n    _swapParameters.feeRecipient = feeRecipient;\n    _swapParameters.isPaused = paused();\n    _swapParameters.swapFee = swapFee;\n  }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/utils/Governable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.4;\n\ninterface IGovernable {\n  event PendingGovernorSet(address _pendingGovernor);\n  event PendingGovernorAccepted();\n\n  function setPendingGovernor(address _pendingGovernor) external;\n\n  function acceptPendingGovernor() external;\n\n  function governor() external view returns (address);\n\n  function pendingGovernor() external view returns (address);\n\n  function isGovernor(address _account) external view returns (bool _isGovernor);\n\n  function isPendingGovernor(address _account) external view returns (bool _isPendingGovernor);\n}\n\nabstract contract Governable is IGovernable {\n  address private _governor;\n  address private _pendingGovernor;\n\n  constructor(address __governor) {\n    require(__governor != address(0), 'Governable: zero address');\n    _governor = __governor;\n  }\n\n  function governor() external view override returns (address) {\n    return _governor;\n  }\n\n  function pendingGovernor() external view override returns (address) {\n    return _pendingGovernor;\n  }\n\n  function setPendingGovernor(address __pendingGovernor) external virtual override onlyGovernor {\n    _setPendingGovernor(__pendingGovernor);\n  }\n\n  function _setPendingGovernor(address __pendingGovernor) internal {\n    require(__pendingGovernor != address(0), 'Governable: zero address');\n    _pendingGovernor = __pendingGovernor;\n    emit PendingGovernorSet(__pendingGovernor);\n  }\n\n  function acceptPendingGovernor() external virtual override onlyPendingGovernor {\n    _acceptPendingGovernor();\n  }\n\n  function _acceptPendingGovernor() internal {\n    require(_pendingGovernor != address(0), 'Governable: no pending governor');\n    _governor = _pendingGovernor;\n    _pendingGovernor = address(0);\n    emit PendingGovernorAccepted();\n  }\n\n  function isGovernor(address _account) public view override returns (bool _isGovernor) {\n    return _account == _governor;\n  }\n\n  function isPendingGovernor(address _account) public view override returns (bool _isPendingGovernor) {\n    return _account == _pendingGovernor;\n  }\n\n  modifier onlyGovernor {\n    require(isGovernor(msg.sender), 'Governable: only governor');\n    _;\n  }\n\n  modifier onlyPendingGovernor {\n    require(isPendingGovernor(msg.sender), 'Governable: only pending governor');\n    _;\n  }\n}\n"
    },
    "contracts/mocks/DCAGlobalParameters/DCAGlobalParameters.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.4;\n\nimport '../../DCAGlobalParameters/DCAGlobalParameters.sol';\n\ncontract DCAGlobalParametersMock is DCAGlobalParameters {\n  constructor(\n    address _governor,\n    address _feeRecipient,\n    IDCATokenDescriptor _nftDescriptor\n  ) DCAGlobalParameters(_governor, _feeRecipient, _nftDescriptor) {}\n}\n"
    },
    "contracts/DCATokenDescriptor/DCATokenDescriptor.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.4;\npragma abicoder v2;\n\nimport '../interfaces/IDCAGlobalParameters.sol';\nimport '../interfaces/IDCAPair.sol';\nimport '../interfaces/IERC20Detailed.sol';\nimport '../libraries/NFTDescriptor.sol';\n\n/// @title Describes NFT token positions\n/// @notice Produces a string containing the data URI for a JSON metadata string\ncontract DCATokenDescriptor is IDCATokenDescriptor {\n  function tokenURI(IDCAPairPositionHandler _positionHandler, uint256 _tokenId) external view override returns (string memory) {\n    IERC20Detailed _tokenA = _positionHandler.tokenA();\n    IERC20Detailed _tokenB = _positionHandler.tokenB();\n    IDCAGlobalParameters _globalParameters = _positionHandler.globalParameters();\n    IDCAPairPositionHandler.UserPosition memory _userPosition = _positionHandler.userPosition(_tokenId);\n\n    return\n      NFTDescriptor.constructTokenURI(\n        NFTDescriptor.ConstructTokenURIParams({\n          tokenId: _tokenId,\n          pair: address(_positionHandler),\n          tokenA: address(_tokenA),\n          tokenB: address(_tokenB),\n          tokenADecimals: _tokenA.decimals(),\n          tokenBDecimals: _tokenB.decimals(),\n          tokenASymbol: _tokenA.symbol(),\n          tokenBSymbol: _tokenB.symbol(),\n          swapInterval: _globalParameters.intervalDescription(_userPosition.swapInterval),\n          swapsExecuted: _userPosition.swapsExecuted,\n          swapped: _userPosition.swapped,\n          swapsLeft: _userPosition.swapsLeft,\n          remaining: _userPosition.remaining,\n          rate: _userPosition.rate,\n          fromA: _userPosition.from == _tokenA\n        })\n      );\n  }\n}\n"
    },
    "contracts/libraries/NFTDescriptor.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.0;\npragma abicoder v2;\n\nimport '@openzeppelin/contracts/utils/Strings.sol';\nimport 'base64-sol/base64.sol';\nimport './NFTSVG.sol';\n\n// Based on Uniswap's NFTDescriptor\nlibrary NFTDescriptor {\n  using Strings for uint256;\n  using Strings for uint32;\n\n  struct ConstructTokenURIParams {\n    address pair;\n    address tokenA;\n    address tokenB;\n    uint8 tokenADecimals;\n    uint8 tokenBDecimals;\n    string tokenASymbol;\n    string tokenBSymbol;\n    string swapInterval;\n    uint32 swapsExecuted;\n    uint32 swapsLeft;\n    uint256 tokenId;\n    uint256 swapped;\n    uint256 remaining;\n    uint192 rate;\n    bool fromA;\n  }\n\n  function constructTokenURI(ConstructTokenURIParams memory _params) internal pure returns (string memory) {\n    string memory _name = _generateName(_params);\n\n    string memory _description = _generateDescription(\n      _params.tokenASymbol,\n      _params.tokenBSymbol,\n      addressToString(_params.pair),\n      addressToString(_params.tokenA),\n      addressToString(_params.tokenB),\n      _params.swapInterval,\n      _params.tokenId\n    );\n\n    string memory _image = Base64.encode(bytes(_generateSVGImage(_params)));\n\n    return\n      string(\n        abi.encodePacked(\n          'data:application/json;base64,',\n          Base64.encode(\n            bytes(\n              abi.encodePacked(\n                '{\"name\":\"',\n                _name,\n                '\", \"description\":\"',\n                _description,\n                '\", \"image\": \"',\n                'data:image/svg+xml;base64,',\n                _image,\n                '\"}'\n              )\n            )\n          )\n        )\n      );\n  }\n\n  function _escapeQuotes(string memory _symbol) private pure returns (string memory) {\n    bytes memory symbolBytes = bytes(_symbol);\n    uint8 quotesCount = 0;\n    for (uint8 i = 0; i < symbolBytes.length; i++) {\n      if (symbolBytes[i] == '\"') {\n        quotesCount++;\n      }\n    }\n    if (quotesCount > 0) {\n      bytes memory escapedBytes = new bytes(symbolBytes.length + (quotesCount));\n      uint256 index;\n      for (uint8 i = 0; i < symbolBytes.length; i++) {\n        if (symbolBytes[i] == '\"') {\n          escapedBytes[index++] = '\\\\';\n        }\n        escapedBytes[index++] = symbolBytes[i];\n      }\n      return string(escapedBytes);\n    }\n    return _symbol;\n  }\n\n  function _generateDescription(\n    string memory _tokenASymbol,\n    string memory _tokenBSymbol,\n    string memory _pairAddress,\n    string memory _tokenAAddress,\n    string memory _tokenBAddress,\n    string memory _interval,\n    uint256 _tokenId\n  ) private pure returns (string memory) {\n    string memory _part1 = string(\n      abi.encodePacked(\n        'This NFT represents a position in a Mean Finance DCA ',\n        _escapeQuotes(_tokenASymbol),\n        '-',\n        _escapeQuotes(_tokenBSymbol),\n        ' pair. ',\n        'The owner of this NFT can modify or redeem the position.\\\\n',\n        '\\\\nPair Address: ',\n        _pairAddress,\n        '\\\\n',\n        _escapeQuotes(_tokenASymbol)\n      )\n    );\n    string memory _part2 = string(\n      abi.encodePacked(\n        ' Address: ',\n        _tokenAAddress,\n        '\\\\n',\n        _escapeQuotes(_tokenBSymbol),\n        ' Address: ',\n        _tokenBAddress,\n        '\\\\nSwap interval: ',\n        _interval,\n        '\\\\nToken ID: ',\n        _tokenId.toString(),\n        '\\\\n\\\\n',\n        unicode' DISCLAIMER: Due diligence is imperative when assessing this NFT. Make sure token addresses match the expected tokens, as token symbols may be imitated.'\n      )\n    );\n    return string(abi.encodePacked(_part1, _part2));\n  }\n\n  function _generateName(ConstructTokenURIParams memory _params) private pure returns (string memory) {\n    return\n      string(\n        abi.encodePacked(\n          'Mean Finance DCA - ',\n          _params.swapInterval,\n          ' - ',\n          _escapeQuotes(_params.tokenASymbol),\n          '/',\n          _escapeQuotes(_params.tokenBSymbol)\n        )\n      );\n  }\n\n  struct DecimalStringParams {\n    // significant figures of decimal\n    uint256 sigfigs;\n    // length of decimal string\n    uint8 bufferLength;\n    // ending index for significant figures (funtion works backwards when copying sigfigs)\n    uint8 sigfigIndex;\n    // index of decimal place (0 if no decimal)\n    uint8 decimalIndex;\n    // start index for trailing/leading 0's for very small/large numbers\n    uint8 zerosStartIndex;\n    // end index for trailing/leading 0's for very small/large numbers\n    uint8 zerosEndIndex;\n    // true if decimal number is less than one\n    bool isLessThanOne;\n  }\n\n  function _generateDecimalString(DecimalStringParams memory params) private pure returns (string memory) {\n    bytes memory buffer = new bytes(params.bufferLength);\n    if (params.isLessThanOne) {\n      buffer[0] = '0';\n      buffer[1] = '.';\n    }\n\n    // add leading/trailing 0's\n    for (uint256 zerosCursor = params.zerosStartIndex; zerosCursor < params.zerosEndIndex + 1; zerosCursor++) {\n      buffer[zerosCursor] = bytes1(uint8(48));\n    }\n    // add sigfigs\n    while (params.sigfigs > 0) {\n      if (params.decimalIndex > 0 && params.sigfigIndex == params.decimalIndex) {\n        buffer[params.sigfigIndex--] = '.';\n      }\n      uint8 charIndex = uint8(48 + (params.sigfigs % 10));\n      buffer[params.sigfigIndex] = bytes1(charIndex);\n      params.sigfigs /= 10;\n      if (params.sigfigs > 0) {\n        params.sigfigIndex--;\n      }\n    }\n    return string(buffer);\n  }\n\n  function _sigfigsRounded(uint256 value, uint8 digits) private pure returns (uint256, bool) {\n    bool extraDigit;\n    if (digits > 5) {\n      value = value / (10**(digits - 5));\n    }\n    bool roundUp = value % 10 > 4;\n    value = value / 10;\n    if (roundUp) {\n      value = value + 1;\n    }\n    // 99999 -> 100000 gives an extra sigfig\n    if (value == 100000) {\n      value /= 10;\n      extraDigit = true;\n    }\n    return (value, extraDigit);\n  }\n\n  function fixedPointToDecimalString(uint256 value, uint8 decimals) internal pure returns (string memory) {\n    if (value == 0) {\n      return '0.0000';\n    }\n\n    bool priceBelow1 = value < 10**decimals;\n\n    // get digit count\n    uint256 temp = value;\n    uint8 digits;\n    while (temp != 0) {\n      digits++;\n      temp /= 10;\n    }\n    // don't count extra digit kept for rounding\n    digits = digits - 1;\n\n    // address rounding\n    (uint256 sigfigs, bool extraDigit) = _sigfigsRounded(value, digits);\n    if (extraDigit) {\n      digits++;\n    }\n\n    DecimalStringParams memory params;\n    if (priceBelow1) {\n      // 7 bytes ( \"0.\" and 5 sigfigs) + leading 0's bytes\n      params.bufferLength = uint8(digits >= 5 ? decimals - digits + 6 : decimals + 2);\n      params.zerosStartIndex = 2;\n      params.zerosEndIndex = uint8(decimals - digits + 1);\n      params.sigfigIndex = uint8(params.bufferLength - 1);\n    } else if (digits >= decimals + 4) {\n      // no decimal in price string\n      params.bufferLength = uint8(digits - decimals + 1);\n      params.zerosStartIndex = 5;\n      params.zerosEndIndex = uint8(params.bufferLength - 1);\n      params.sigfigIndex = 4;\n    } else {\n      // 5 sigfigs surround decimal\n      params.bufferLength = 6;\n      params.sigfigIndex = 5;\n      params.decimalIndex = uint8(digits - decimals + 1);\n    }\n    params.sigfigs = sigfigs;\n    params.isLessThanOne = priceBelow1;\n\n    return _generateDecimalString(params);\n  }\n\n  function addressToString(address _addr) internal pure returns (string memory) {\n    bytes memory s = new bytes(40);\n    for (uint256 i = 0; i < 20; i++) {\n      bytes1 b = bytes1(uint8(uint256(uint160(_addr)) / (2**(8 * (19 - i)))));\n      bytes1 hi = bytes1(uint8(b) / 16);\n      bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\n      s[2 * i] = _char(hi);\n      s[2 * i + 1] = _char(lo);\n    }\n    return string(abi.encodePacked('0x', string(s)));\n  }\n\n  function _char(bytes1 b) private pure returns (bytes1 c) {\n    if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\n    else return bytes1(uint8(b) + 0x57);\n  }\n\n  function _generateSVGImage(ConstructTokenURIParams memory _params) private pure returns (string memory svg) {\n    string memory _fromSymbol;\n    string memory _toSymbol;\n    uint8 _fromDecimals;\n    uint8 _toDecimals;\n    if (_params.fromA) {\n      _fromSymbol = _escapeQuotes(_params.tokenASymbol);\n      _fromDecimals = _params.tokenADecimals;\n      _toSymbol = _escapeQuotes(_params.tokenBSymbol);\n      _toDecimals = _params.tokenBDecimals;\n    } else {\n      _fromSymbol = _escapeQuotes(_params.tokenBSymbol);\n      _fromDecimals = _params.tokenBDecimals;\n      _toSymbol = _escapeQuotes(_params.tokenASymbol);\n      _toDecimals = _params.tokenADecimals;\n    }\n    NFTSVG.SVGParams memory _svgParams = NFTSVG.SVGParams({\n      tokenId: _params.tokenId,\n      tokenA: addressToString(_params.tokenA),\n      tokenB: addressToString(_params.tokenB),\n      tokenASymbol: _escapeQuotes(_params.tokenASymbol),\n      tokenBSymbol: _escapeQuotes(_params.tokenBSymbol),\n      interval: _params.swapInterval,\n      swapsExecuted: _params.swapsExecuted,\n      swapsLeft: _params.swapsLeft,\n      swapped: string(abi.encodePacked(fixedPointToDecimalString(_params.swapped, _toDecimals), ' ', _toSymbol)),\n      averagePrice: string(\n        abi.encodePacked(\n          fixedPointToDecimalString(_params.swapsExecuted > 0 ? _params.swapped / _params.swapsExecuted : 0, _toDecimals),\n          ' ',\n          _toSymbol\n        )\n      ),\n      remaining: string(abi.encodePacked(fixedPointToDecimalString(_params.remaining, _fromDecimals), ' ', _fromSymbol)),\n      rate: string(abi.encodePacked(fixedPointToDecimalString(_params.rate, _fromDecimals), ' ', _fromSymbol))\n    });\n\n    return NFTSVG.generateSVG(_svgParams);\n  }\n}\n"
    },
    "base64-sol/base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides a function for encoding some bytes in base64\nlibrary Base64 {\n    string internal constant TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return '';\n        \n        // load the table into memory\n        string memory table = TABLE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n            \n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n            \n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n            \n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n            \n            // run over the input, 3 bytes at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n               dataPtr := add(dataPtr, 3)\n               \n               // read 3 bytes\n               let input := mload(dataPtr)\n               \n               // write 4 characters\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F)))))\n               resultPtr := add(resultPtr, 1)\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F)))))\n               resultPtr := add(resultPtr, 1)\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(shr( 6, input), 0x3F)))))\n               resultPtr := add(resultPtr, 1)\n               mstore(resultPtr, shl(248, mload(add(tablePtr, and(        input,  0x3F)))))\n               resultPtr := add(resultPtr, 1)\n            }\n            \n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\n        }\n        \n        return result;\n    }\n}\n"
    },
    "contracts/libraries/NFTSVG.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.4;\n\nimport '@openzeppelin/contracts/utils/Strings.sol';\n\n/// @title NFTSVG\n/// @notice Provides a function for generating an SVG associated with a DCA NFT. Based on Uniswap's NFTDescriptor. Background by bgjar.com\nlibrary NFTSVG {\n  using Strings for uint256;\n  using Strings for uint32;\n\n  struct SVGParams {\n    string tokenA;\n    string tokenB;\n    string tokenASymbol;\n    string tokenBSymbol;\n    string interval;\n    uint32 swapsExecuted;\n    uint32 swapsLeft;\n    uint256 tokenId;\n    string swapped;\n    string averagePrice;\n    string remaining;\n    string rate;\n  }\n\n  function generateSVG(SVGParams memory params) internal pure returns (string memory svg) {\n    return\n      string(\n        abi.encodePacked(\n          _generateSVGDefs(),\n          _generateSVGBorderText(params.tokenA, params.tokenB, params.tokenASymbol, params.tokenBSymbol),\n          _generateSVGCardMantle(params.tokenASymbol, params.tokenBSymbol, params.interval),\n          _generageSVGProgressArea(params.swapsExecuted, params.swapsLeft),\n          _generateSVGPositionData(params.tokenId, params.swapped, params.averagePrice, params.remaining, params.rate),\n          '</svg>'\n        )\n      );\n  }\n\n  function _generateSVGDefs() private pure returns (string memory svg) {\n    svg = string(\n      abi.encodePacked(\n        '<svg width=\"290\" height=\"560\" viewBox=\"0 0 290 560\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">',\n        '<defs><linearGradient x1=\"118.1%\" y1=\"10.5%\" x2=\"-18.1%\" y2=\"89.5%\" gradientUnits=\"userSpaceOnUse\" id=\"LinearGradient\"><stop stop-color=\"rgba(13, 5, 20, 1)\" offset=\"0\"></stop><stop stop-color=\"rgba(47, 19, 66, 1)\" offset=\"0.7\"></stop><stop stop-color=\"rgba(35, 17, 51, 1)\" offset=\"1\"></stop></linearGradient><clipPath id=\"corners\"><rect width=\"290\" height=\"560\" rx=\"40\" ry=\"40\" /></clipPath><path id=\"text-path-a\" d=\"M40 12 H250 A28 28 0 0 1 278 40 V520 A28 28 0 0 1 250 548 H40 A28 28 0 0 1 12 520 V40 A28 28 0 0 1 40 12 z\" /><mask id=\"none\" maskContentUnits=\"objectBoundingBox\"><rect width=\"1\" height=\"1\" fill=\"white\" /></mask><linearGradient id=\"grad-symbol\"><stop offset=\"0.8\" stop-color=\"white\" stop-opacity=\"1\" /><stop offset=\".95\" stop-color=\"white\" stop-opacity=\"0\" /></linearGradient><mask id=\"fade-symbol\" maskContentUnits=\"userSpaceOnUse\"><rect width=\"290px\" height=\"200px\" fill=\"url(#grad-symbol)\" /></mask></defs>',\n        '<g clip-path=\"url(#corners)\">',\n        '<rect width=\"290\" height=\"560\" x=\"0\" y=\"0\" fill=\"url(#LinearGradient)\"></rect>',\n        '<path d=\"M290 0L248.61 0L290 61.48z\" fill=\"rgba(255, 255, 255, .1)\"></path>',\n        '<path d=\"M248.61 0L290 61.48L290 189.35999999999999L200.75 0z\" fill=\"rgba(255, 255, 255, .075)\"></path>',\n        '<path d=\"M200.75 0L290 189.35999999999999L290 294.91999999999996L112.52 0z\" fill=\"rgba(255, 255, 255, .05)\"></path>',\n        '<path d=\"M112.51999999999998 0L290 294.91999999999996L290 357.79999999999995L32.78999999999998 0z\" fill=\"rgba(255, 255, 255, .025)\"></path>',\n        '<path d=\"M0 560L40.27 560L0 402.35z\" fill=\"rgba(0, 0, 0, .1)\"></path>',\n        '<path d=\"M0 402.35L40.27 560L137.96 560L0 221.89000000000001z\" fill=\"rgba(0, 0, 0, .075)\"></path>',\n        '<path d=\"M0 221.89L137.96 560L153.85600000000002 560L0 183.92z\" fill=\"rgba(0, 0, 0, .05)\"></path>',\n        '<path d=\"M0 183.91999999999996L153.85000000000002 560L156.66000000000003 560L0 151.61999999999995z\" fill=\"rgba(0, 0, 0, .025)\"></path>',\n        '</g>'\n      )\n    );\n  }\n\n  function _generateSVGBorderText(\n    string memory _tokenA,\n    string memory _tokenB,\n    string memory _tokenASymbol,\n    string memory _tokenBSymbol\n  ) private pure returns (string memory svg) {\n    string memory _tokenAText = string(abi.encodePacked(_tokenA, unicode'  ', _tokenASymbol));\n    string memory _tokenBText = string(abi.encodePacked(_tokenB, unicode'  ', _tokenBSymbol));\n    svg = string(\n      abi.encodePacked(\n        '<text text-rendering=\"optimizeSpeed\"><textPath startOffset=\"-100%\" fill=\"white\" font-family=\"\\'Courier New\\', monospace\" font-size=\"10px\" xlink:href=\"#text-path-a\">',\n        _tokenAText,\n        '<animate additive=\"sum\" attributeName=\"startOffset\" from=\"0%\" to=\"100%\" begin=\"0s\" dur=\"30s\" repeatCount=\"indefinite\" /></textPath><textPath startOffset=\"0%\" fill=\"white\" font-family=\"\\'Courier New\\', monospace\" font-size=\"10px\" xlink:href=\"#text-path-a\">',\n        _tokenAText,\n        '<animate additive=\"sum\" attributeName=\"startOffset\" from=\"0%\" to=\"100%\" begin=\"0s\" dur=\"30s\" repeatCount=\"indefinite\" /></textPath><textPath startOffset=\"50%\" fill=\"white\" font-family=\"\\'Courier New\\', monospace\" font-size=\"10px\" xlink:href=\"#text-path-a\">',\n        _tokenBText,\n        '<animate additive=\"sum\" attributeName=\"startOffset\" from=\"0%\" to=\"100%\" begin=\"0s\" dur=\"30s\" repeatCount=\"indefinite\" /></textPath><textPath startOffset=\"-50%\" fill=\"white\" font-family=\"\\'Courier New\\', monospace\" font-size=\"10px\" xlink:href=\"#text-path-a\">',\n        _tokenBText,\n        '<animate additive=\"sum\" attributeName=\"startOffset\" from=\"0%\" to=\"100%\" begin=\"0s\" dur=\"30s\" repeatCount=\"indefinite\" /></textPath></text>'\n      )\n    );\n  }\n\n  function _generateSVGCardMantle(\n    string memory _tokenASymbol,\n    string memory _tokenBSymbol,\n    string memory _interval\n  ) private pure returns (string memory svg) {\n    svg = string(\n      abi.encodePacked(\n        '<g mask=\"url(#fade-symbol)\">'\n        '<rect fill=\"none\" x=\"0px\" y=\"0px\" width=\"290px\" height=\"200px\" />'\n        '<text y=\"70px\" x=\"32px\" fill=\"white\" font-family=\"\\'Courier New\\', monospace\" font-weight=\"200\" font-size=\"35px\">',\n        _tokenASymbol,\n        '/',\n        _tokenBSymbol,\n        '</text>',\n        '<text y=\"115px\" x=\"32px\" fill=\"white\" font-family=\"\\'Courier New\\', monospace\" font-weight=\"200\" font-size=\"28px\">',\n        _interval,\n        '</text>'\n        '</g>'\n      )\n    );\n  }\n\n  function _generageSVGProgressArea(uint32 _swapsExecuted, uint32 _swapsLeft) private pure returns (string memory svg) {\n    uint256 _positionNow = 170 + ((314 - 170) / (_swapsExecuted + _swapsLeft)) * _swapsExecuted;\n    svg = string(\n      abi.encodePacked(\n        '<rect x=\"16\" y=\"16\" width=\"258\" height=\"528\" rx=\"26\" ry=\"26\" fill=\"rgba(0,0,0,0)\" stroke=\"rgba(255,255,255,0.2)\" />',\n        '<g mask=\"url(#none)\" style=\"transform:translate(80px,169px)\"><rect x=\"-16px\" y=\"-16px\" width=\"180px\" height=\"180px\" fill=\"none\" /><path d=\"M1 1 L1 145\" stroke=\"rgba(0,0,0,0.3)\" stroke-width=\"32px\" fill=\"none\" stroke-linecap=\"round\" /></g>',\n        '<g mask=\"url(#none)\" style=\"transform:translate(80px,169px)\"><rect x=\"-16px\" y=\"-16px\" width=\"180px\" height=\"180px\" fill=\"none\" /><path d=\"M1 1 L1 145\" stroke=\"rgba(255,255,255,1)\" fill=\"none\" stroke-linecap=\"round\" /></g>',\n        '<circle cx=\"81px\" cy=\"170px\" r=\"4px\" fill=\"#dddddd\" />',\n        '<circle cx=\"81px\" cy=\"',\n        _positionNow.toString(),\n        'px\" r=\"5px\" fill=\"white\" />',\n        '<circle cx=\"81px\" cy=\"314px\" r=\"4px\" fill=\"#dddddd\" /><text x=\"100px\" y=\"174px\" font-family=\"\\'Courier New\\', monospace\" font-size=\"12px\" fill=\"white\"><tspan fill=\"rgba(255,255,255,0.6)\">Executed*: </tspan>',\n        _swapsExecuted.toString(),\n        ' swaps</text><text x=\"40px\" y=\"',\n        (_positionNow + 4).toString(),\n        'px\" font-family=\"\\'Courier New\\', monospace\" font-size=\"12px\" fill=\"white\">Now</text><text x=\"100px\" y=\"318px\" font-family=\"\\'Courier New\\', monospace\" font-size=\"12px\" fill=\"white\"><tspan fill=\"rgba(255,255,255,0.6)\">Left: </tspan>',\n        _swapsLeft.toString(),\n        ' swaps</text>'\n      )\n    );\n  }\n\n  function _generateSVGPositionData(\n    uint256 _tokenId,\n    string memory _swapped,\n    string memory _averagePrice,\n    string memory _remaining,\n    string memory _rate\n  ) private pure returns (string memory svg) {\n    svg = string(\n      abi.encodePacked(\n        _generateData('Id', _tokenId.toString(), 364),\n        _generateData('Swapped*', _swapped, 394),\n        _generateData('Avg Price', _averagePrice, 424),\n        _generateData('Remaining', _remaining, 454),\n        _generateData('Rate', _rate, 484),\n        '<g style=\"transform:translate(25px, 514px)\">',\n        '<text x=\"12px\" y=\"17px\" font-family=\"\\'Courier New\\', monospace\" font-size=\"11px\" fill=\"white\">',\n        '<tspan fill=\"rgba(255,255,255,0.8)\">* since start or last withdraw</tspan>',\n        '</text>',\n        '</g>'\n      )\n    );\n  }\n\n  function _generateData(\n    string memory _title,\n    string memory _data,\n    uint256 _yCoord\n  ) private pure returns (string memory svg) {\n    uint256 _strLength = bytes(_title).length + bytes(_data).length + 2;\n    svg = string(\n      abi.encodePacked(\n        '<g style=\"transform:translate(29px, ',\n        _yCoord.toString(),\n        'px)\">',\n        '<rect width=\"',\n        uint256(7 * (_strLength + 4)).toString(),\n        'px\" height=\"26px\" rx=\"8px\" ry=\"8px\" fill=\"rgba(0,0,0,0.6)\" />',\n        '<text x=\"12px\" y=\"17px\" font-family=\"\\'Courier New\\', monospace\" font-size=\"12px\" fill=\"white\">',\n        '<tspan fill=\"rgba(255,255,255,0.6)\">',\n        _title,\n        ': </tspan>',\n        _data,\n        '</text>',\n        '</g>'\n      )\n    );\n  }\n}\n"
    },
    "contracts/mocks/NFTDescriptor.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.4;\n\nimport '../libraries/NFTDescriptor.sol';\n\ncontract NFTDescriptorMock {\n  function fixedPointToDecimalString(uint256 value, uint8 decimals) public pure returns (string memory) {\n    return NFTDescriptor.fixedPointToDecimalString(value, decimals);\n  }\n\n  function addressToString(address _addr) public pure returns (string memory) {\n    return NFTDescriptor.addressToString(_addr);\n  }\n}\n"
    },
    "contracts/mocks/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.4;\n\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\ncontract ERC20Mock is ERC20 {\n  uint8 private _decimals;\n\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    uint8 __decimals,\n    address _initialAccount,\n    uint256 _initialBalance\n  ) payable ERC20(_name, _symbol) {\n    _decimals = __decimals;\n    if (_initialBalance > 0) {\n      _mint(_initialAccount, _initialBalance);\n    }\n  }\n\n  function mint(address _account, uint256 _amount) public {\n    _mint(_account, _amount);\n  }\n\n  function burn(address _account, uint256 _amount) public {\n    _burn(_account, _amount);\n  }\n\n  function transferInternal(\n    address _from,\n    address _to,\n    uint256 _value\n  ) public {\n    _transfer(_from, _to, _value);\n  }\n\n  function approveInternal(\n    address _owner,\n    address _spender,\n    uint256 _value\n  ) public {\n    _approve(_owner, _spender, _value);\n  }\n\n  function decimals() public view virtual override returns (uint8) {\n    return _decimals;\n  }\n}\n"
    },
    "contracts/utils/CollectableDust.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.4;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\ninterface ICollectableDust {\n  event DustSent(address _to, address token, uint256 amount);\n\n  // solhint-disable-next-line func-name-mixedcase\n  function ETH() external view returns (address);\n\n  function sendDust(\n    address _to,\n    address _token,\n    uint256 _amount\n  ) external;\n}\n\nabstract contract CollectableDust is ICollectableDust {\n  using SafeERC20 for IERC20;\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  address public constant override ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n  EnumerableSet.AddressSet internal _protocolTokens;\n\n  function _addProtocolToken(address _token) internal {\n    require(!_protocolTokens.contains(_token), 'CollectableDust: token already part of protocol');\n    _protocolTokens.add(_token);\n  }\n\n  function _removeProtocolToken(address _token) internal {\n    require(_protocolTokens.contains(_token), 'CollectableDust: token is not part of protocol');\n    _protocolTokens.remove(_token);\n  }\n\n  function _sendDust(\n    address _to,\n    address _token,\n    uint256 _amount\n  ) internal {\n    require(_to != address(0), 'CollectableDust: zero address');\n    require(!_protocolTokens.contains(_token), 'CollectableDust: token is part of protocol');\n    if (_token == ETH) {\n      payable(_to).transfer(_amount);\n    } else {\n      IERC20(_token).safeTransfer(_to, _amount);\n    }\n    emit DustSent(_to, _token, _amount);\n  }\n}\n"
    },
    "contracts/mocks/DCAPairSwapCallee.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.4;\n\nimport '@openzeppelin/contracts/utils/Address.sol';\n\nimport '../interfaces/IDCAPairSwapCallee.sol';\nimport '../interfaces/IDCAPair.sol';\n\ncontract DCAPairSwapCalleeMock is IDCAPairSwapCallee {\n  struct SwapCall {\n    address pair;\n    address sender;\n    IERC20Detailed tokenA;\n    IERC20Detailed tokenB;\n    uint256 amountBorrowedTokenA;\n    uint256 amountBorrowedTokenB;\n    bool isRewardTokenA;\n    uint256 rewardAmount;\n    uint256 amountToProvide;\n    bytes data;\n  }\n\n  // solhint-disable-next-line var-name-mixedcase\n  uint256 private _initialBalanceA;\n  uint256 private _initialBalanceB;\n  SwapCall private _lastCall;\n  bool private _returnAsExpected = true;\n  uint256 private _amountToReturnTokenA;\n  uint256 private _amountToReturnTokenB;\n\n  constructor(uint256 __initialBalanceA, uint256 __initialBalanceB) {\n    _initialBalanceA = __initialBalanceA;\n    _initialBalanceB = __initialBalanceB;\n  }\n\n  // solhint-disable-next-line func-name-mixedcase\n  function DCAPairSwapCall(\n    address _sender,\n    IERC20Detailed _tokenA,\n    IERC20Detailed _tokenB,\n    uint256 _amountBorrowedTokenA,\n    uint256 _amountBorrowedTokenB,\n    bool _isRewardTokenA,\n    uint256 _rewardAmount,\n    uint256 _amountToProvide,\n    bytes calldata _data\n  ) public override {\n    require(\n      _tokenA.balanceOf(address(this)) == _initialBalanceA + _amountBorrowedTokenA + (_isRewardTokenA ? _rewardAmount : 0),\n      'DCAPairSwapCallee: token A not sent optimistically'\n    );\n    require(\n      _tokenB.balanceOf(address(this)) == _initialBalanceB + _amountBorrowedTokenB + (_isRewardTokenA ? 0 : _rewardAmount),\n      'DCAPairSwapCallee: token B not sent optimistically'\n    );\n\n    _lastCall = SwapCall(\n      msg.sender,\n      _sender,\n      _tokenA,\n      _tokenB,\n      _amountBorrowedTokenA,\n      _amountBorrowedTokenB,\n      _isRewardTokenA,\n      _rewardAmount,\n      _amountToProvide,\n      _data\n    );\n\n    if (_returnAsExpected) {\n      _tokenA.transfer(msg.sender, _amountBorrowedTokenA + (_isRewardTokenA ? 0 : _amountToProvide));\n      _tokenB.transfer(msg.sender, _amountBorrowedTokenB + (_isRewardTokenA ? _amountToProvide : 0));\n    } else {\n      _tokenA.transfer(msg.sender, _amountToReturnTokenA);\n      _tokenB.transfer(msg.sender, _amountToReturnTokenB);\n    }\n  }\n\n  function returnSpecificAmounts(uint256 __amountToReturnTokenA, uint256 __amountToReturnTokenB) public {\n    _amountToReturnTokenA = __amountToReturnTokenA;\n    _amountToReturnTokenB = __amountToReturnTokenB;\n    _returnAsExpected = false;\n  }\n\n  function wasThereACall() public view returns (bool) {\n    return _lastCall.pair != address(0);\n  }\n\n  function getLastCall() public view returns (SwapCall memory __lastCall) {\n    __lastCall = _lastCall;\n  }\n}\n\ncontract ReentrantDCAPairSwapCalleeMock is IDCAPairSwapCallee {\n  using Address for address;\n\n  bytes internal _attack;\n\n  function setAttack(bytes memory __attack) external {\n    _attack = __attack;\n  }\n\n  // solhint-disable-next-line func-name-mixedcase\n  function DCAPairSwapCall(\n    address,\n    IERC20Detailed,\n    IERC20Detailed,\n    uint256,\n    uint256,\n    bool,\n    uint256,\n    uint256,\n    bytes calldata\n  ) public override {\n    (msg.sender).functionCall(_attack);\n  }\n}\n"
    },
    "contracts/mocks/DCAPairLoanCallee.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.4;\n\nimport '@openzeppelin/contracts/utils/Address.sol';\n\nimport '../interfaces/IDCAPairLoanCallee.sol';\nimport '../interfaces/IDCAPair.sol';\n\ncontract DCAPairLoanCalleeMock is IDCAPairLoanCallee {\n  struct LoanCall {\n    address pair;\n    address sender;\n    IERC20Detailed tokenA;\n    IERC20Detailed tokenB;\n    uint256 amountBorrowedTokenA;\n    uint256 amountBorrowedTokenB;\n    uint256 feeTokenA;\n    uint256 feeTokenB;\n    bytes data;\n  }\n\n  uint256 private _initialBalanceA;\n  uint256 private _initialBalanceB;\n  LoanCall private _lastCall;\n  bool private _returnAsExpected = true;\n  uint256 private _amountToReturnTokenA;\n  uint256 private _amountToReturnTokenB;\n\n  constructor(uint256 __initialBalanceA, uint256 __initialBalanceB) {\n    _initialBalanceA = __initialBalanceA;\n    _initialBalanceB = __initialBalanceB;\n  }\n\n  // solhint-disable-next-line func-name-mixedcase\n  function DCAPairLoanCall(\n    address _sender,\n    IERC20Detailed _tokenA,\n    IERC20Detailed _tokenB,\n    uint256 _amountBorrowedTokenA,\n    uint256 _amountBorrowedTokenB,\n    uint256 _feeTokenA,\n    uint256 _feeTokenB,\n    bytes calldata _data\n  ) public override {\n    require(_tokenA.balanceOf(address(this)) == _initialBalanceA + _amountBorrowedTokenA, 'DCAPairLoanCallee: token A not sent optimistically');\n    require(_tokenB.balanceOf(address(this)) == _initialBalanceB + _amountBorrowedTokenB, 'DCAPairLoanCallee: token B not sent optimistically');\n\n    _lastCall = LoanCall(msg.sender, _sender, _tokenA, _tokenB, _amountBorrowedTokenA, _amountBorrowedTokenB, _feeTokenA, _feeTokenB, _data);\n\n    if (_returnAsExpected) {\n      _tokenA.transfer(msg.sender, _amountBorrowedTokenA);\n      _tokenB.transfer(msg.sender, _amountBorrowedTokenB);\n    } else {\n      _tokenA.transfer(msg.sender, _amountToReturnTokenA);\n      _tokenB.transfer(msg.sender, _amountToReturnTokenB);\n    }\n  }\n\n  function returnSpecificAmounts(uint256 __amountToReturnTokenA, uint256 __amountToReturnTokenB) public {\n    _amountToReturnTokenA = __amountToReturnTokenA;\n    _amountToReturnTokenB = __amountToReturnTokenB;\n    _returnAsExpected = false;\n  }\n\n  function wasThereACall() public view returns (bool) {\n    return _lastCall.pair != address(0);\n  }\n\n  function getLastCall() public view returns (LoanCall memory __lastCall) {\n    __lastCall = _lastCall;\n  }\n}\n\ncontract ReentrantDCAPairLoanCalleeMock is IDCAPairLoanCallee {\n  using Address for address;\n\n  bytes internal _attack;\n\n  function setAttack(bytes memory __attack) external {\n    _attack = __attack;\n  }\n\n  // solhint-disable-next-line func-name-mixedcase\n  function DCAPairLoanCall(\n    address,\n    IERC20Detailed,\n    IERC20Detailed,\n    uint256,\n    uint256,\n    uint256,\n    uint256,\n    bytes calldata\n  ) public override {\n    (msg.sender).functionCall(_attack);\n  }\n}\n"
    },
    "contracts/mocks/DCAPair/DCAPairSwapHandler.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.4;\npragma abicoder v2;\n\nimport '../../DCAPair/DCAPairSwapHandler.sol';\nimport './DCAPairParameters.sol';\n\ncontract DCAPairSwapHandlerMock is DCAPairSwapHandler, DCAPairParametersMock {\n  uint32 private _customTimestamp;\n\n  constructor(\n    IERC20Detailed _token0,\n    IERC20Detailed _token1,\n    IDCAGlobalParameters _globalParameters,\n    ISlidingOracle _oracle\n  ) DCAPairParametersMock(_globalParameters, _token0, _token1) DCAPairSwapHandler(_oracle) {\n    /* */\n  }\n\n  // SwapHandler\n\n  function registerSwap(\n    uint32 _swapInterval,\n    address _token,\n    uint256 _internalAmountUsedToSwap,\n    uint256 _ratePerUnit,\n    uint32 _swapToRegister\n  ) public {\n    _registerSwap(_swapInterval, _token, _internalAmountUsedToSwap, _ratePerUnit, _swapToRegister);\n  }\n\n  function getAmountToSwap(\n    uint32 _swapInterval,\n    address _tokenAddress,\n    uint32 _swap\n  ) public view returns (uint256) {\n    return _getAmountToSwap(_swapInterval, _tokenAddress, _swap);\n  }\n\n  function setBlockTimestamp(uint32 _blockTimestamp) public {\n    _customTimestamp = _blockTimestamp;\n  }\n\n  function _getTimestamp() internal view override returns (uint32 _blockTimestamp) {\n    _blockTimestamp = (_customTimestamp > 0) ? _customTimestamp : super._getTimestamp();\n  }\n\n  // Mocks setters\n\n  function addNewRatePerUnit(\n    uint32 _swapInterval,\n    address _tokenAddress,\n    uint32 _swap,\n    uint256 _ratePerUnit\n  ) public {\n    _addNewRatePerUnit(_swapInterval, _tokenAddress, _swap, _ratePerUnit);\n  }\n\n  function setSwapAmountAccumulator(\n    uint32 _swapInterval,\n    address _tokenAddress,\n    uint256 _swapAmountAccumulator\n  ) public {\n    swapAmountAccumulator[_swapInterval][_tokenAddress] = _swapAmountAccumulator;\n  }\n\n  function setLastSwapPerformed(uint32 _swapInterval, uint32 _lastSwapPerformend) public {\n    lastSwapPerformed[_swapInterval] = _lastSwapPerformend;\n  }\n}\n"
    },
    "contracts/mocks/DCAPair/DCAPairParameters.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.4;\n\nimport '../../DCAPair/DCAPairParameters.sol';\n\ncontract DCAPairParametersMock is DCAPairParameters {\n  constructor(\n    IDCAGlobalParameters _globalParameters,\n    IERC20Detailed _tokenA,\n    IERC20Detailed _tokenB\n  ) DCAPairParameters(_globalParameters, _tokenA, _tokenB) {}\n\n  // Mocks setters\n\n  function magnitudeA() public view returns (uint256) {\n    return _magnitudeA;\n  }\n\n  function magnitudeB() public view returns (uint256) {\n    return _magnitudeB;\n  }\n\n  function internalBalanceOf(address _token) public view returns (uint256) {\n    return _balances[_token];\n  }\n\n  function setInternalBalances(uint256 _amountTokenA, uint256 _amountTokenB) public {\n    _balances[address(tokenA)] = _amountTokenA;\n    _balances[address(tokenB)] = _amountTokenB;\n  }\n\n  function setSwapAmountDelta(\n    uint32 _swapInterval,\n    address _tokenAddress,\n    uint32 _swap,\n    int256 _delta\n  ) public {\n    swapAmountDelta[_swapInterval][_tokenAddress][_swap] = _delta;\n  }\n\n  function setAcummRatesPerUnit(\n    uint32 _swapInterval,\n    address _tokenAddress,\n    uint32 _swap,\n    uint256 _accumRatePerUnit\n  ) public {\n    _accumRatesPerUnit[_swapInterval][_tokenAddress][_swap] = _accumRatePerUnit;\n  }\n\n  function accumRatesPerUnit(\n    uint32 _swapInterval,\n    address _tokenAddress,\n    uint32 _swap\n  ) public view returns (uint256) {\n    return _accumRatesPerUnit[_swapInterval][_tokenAddress][_swap];\n  }\n\n  function setPerformedSwaps(uint32 _swapInterval, uint32 _performedSwaps) public {\n    performedSwaps[_swapInterval] = _performedSwaps;\n  }\n\n  function setRatePerUnit(\n    uint32 _swapInterval,\n    address _tokenAddress,\n    uint32 _swap,\n    uint256 _rate\n  ) public {\n    _accumRatesPerUnit[_swapInterval][_tokenAddress][_swap] = _rate;\n  }\n\n  function getFeeFromAmount(uint32 _feeAmount, uint256 _amount) public view returns (uint256) {\n    return _getFeeFromAmount(_feeAmount, _amount);\n  }\n\n  function feePrecision() public view returns (uint24) {\n    return _feePrecision;\n  }\n}\n"
    },
    "contracts/mocks/DCAPair/DCAPairPositionHandler.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.4;\n\nimport '../../DCAPair/DCAPairPositionHandler.sol';\nimport './DCAPairParameters.sol';\n\ncontract DCAPairPositionHandlerMock is DCAPairPositionHandler, DCAPairParametersMock {\n  constructor(\n    IDCAGlobalParameters _globalParameters,\n    IERC20Detailed _tokenA,\n    IERC20Detailed _tokenB\n  ) DCAPairParametersMock(_globalParameters, _tokenA, _tokenB) DCAPairPositionHandler(_tokenA, _tokenB) {\n    /* */\n  }\n\n  // PositionHandler\n  function internalPosition(uint256 _dcaId) external view returns (DCA memory _dca) {\n    _dca = _userPositions[_dcaId];\n  }\n\n  function modifyPosition(\n    uint256 _dcaId,\n    uint256 _totalNecessary,\n    uint256 _unswapped,\n    uint192 _newRate,\n    uint32 _newAmountOfSwaps\n  ) external {\n    _modifyPosition(_dcaId, _totalNecessary, _unswapped, _newRate, _newAmountOfSwaps);\n  }\n}\n"
    },
    "contracts/mocks/DCAPair/DCAPairLoanHandler.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.4;\n\nimport '../../DCAPair/DCAPairLoanHandler.sol';\nimport './DCAPairParameters.sol';\n\ncontract DCAPairLoanHandlerMock is DCAPairLoanHandler, DCAPairParametersMock {\n  constructor(\n    IERC20Detailed _token0,\n    IERC20Detailed _token1,\n    IDCAGlobalParameters _globalParameters\n  ) DCAPairParametersMock(_globalParameters, _token0, _token1) {}\n}\n"
    },
    "contracts/mocks/StaticSlidingOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.4;\n\nimport '../interfaces/ISlidingOracle.sol';\n\ncontract StaticSlidingOracle is ISlidingOracle {\n  uint256 public rate;\n  uint256 public decimals;\n\n  constructor(uint256 _rate, uint256 _decimals) {\n    rate = _rate;\n    decimals = _decimals;\n  }\n\n  function setRate(uint256 _rate, uint256 _decimals) public {\n    rate = _rate;\n    decimals = _decimals;\n  }\n\n  function current(\n    address _tokenIn,\n    uint256 _amountIn,\n    address _tokenOut\n  ) public view override returns (uint256 _amountOut) {\n    _tokenIn;\n    _tokenOut;\n    _amountOut = (_amountIn * rate) / 10**decimals;\n  }\n\n  function quote(\n    address _tokenIn,\n    uint256 _amountIn,\n    address _tokenOut,\n    uint256 _granularity\n  ) external view override returns (uint256 _amountOut) {\n    _granularity;\n    return current(_tokenIn, _amountIn, _tokenOut);\n  }\n}\n"
    },
    "contracts/mocks/utils/CollectableDust.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.4;\n\nimport '../../utils/CollectableDust.sol';\n\ncontract CollectableDustMock is CollectableDust {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  constructor() {}\n\n  function addProtocolToken(address _token) external {\n    _addProtocolToken(_token);\n  }\n\n  function removeProtocolToken(address _token) external {\n    _removeProtocolToken(_token);\n  }\n\n  function containsProtocolToken(address _token) external view returns (bool) {\n    return _protocolTokens.contains(_token);\n  }\n\n  function sendDust(\n    address _to,\n    address _token,\n    uint256 _amount\n  ) external override {\n    _sendDust(_to, _token, _amount);\n  }\n}\n"
    },
    "contracts/mocks/utils/Governable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity 0.8.4;\n\nimport '../../utils/Governable.sol';\n\ncontract GovernableMock is Governable {\n  constructor(address _governor) Governable(_governor) {}\n\n  function onlyGovernorAllowed() external onlyGovernor {}\n\n  function onlyPendingGovernorAllowed() external onlyPendingGovernor {}\n\n  function setPendingGovernorInternal(address _pendingGovernor) external {\n    _setPendingGovernor(_pendingGovernor);\n  }\n\n  function acceptPendingGovernorInternal() external {\n    _acceptPendingGovernor();\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}